# This schema defines the data models for the Health Florence application

type User @model @auth(rules: [
  { allow: public, provider: apiKey, operations: [create, read, update, delete] },
  { allow: owner }
]) {
  id: ID!
  email: String!
  firstName: String!
  lastName: String!
  phoneNumber: String
  dateOfBirth: AWSDate
  address: String
  city: String
  state: String
  zipCode: String
  emergencyContactName: String
  emergencyContactPhone: String
  allergies: String
  medicalConditions: String
  currentMedications: String
  height: Float
  weight: Float
  gender: String
  bloodType: String
  role: String! @default(value: "user")
  
  # Enhanced fields for production
  isActive: Boolean! @default(value: "true")
  lastLoginAt: AWSDateTime
  loginCount: Int! @default(value: "0")
  preferences: AWSJSON
  notificationSettings: AWSJSON
  privacySettings: AWSJSON
  subscriptionTier: String @default(value: "basic")
  subscriptionExpiresAt: AWSDateTime
  
  createdAt: AWSDateTime!
  updatedAt: AWSDateTime!
  dietaryPlans: [DietaryPlan] @hasMany(fields: ["id"])
  healthGoals: [HealthGoal] @hasMany(fields: ["id"])
  healthConditions: [HealthCondition] @hasMany(fields: ["id"])
  haicRewards: [HAICReward] @hasMany(fields: ["id"])
}

type Expert @model @auth(rules: [
  { allow: public, provider: apiKey, operations: [read, create, update, delete] },
  { allow: owner, operations: [create, update, delete] }
]) {
  id: ID!
  userId: ID!
  user: User @hasOne(fields: ["userId"])
  
  # Professional Information
  specialization: String!
  subSpecializations: [String]
  licenseNumber: String!
  yearsOfExperience: Int!
  education: [String]
  certifications: [String]
  languages: [String]
  
  # Practice Information
  practiceName: String
  practiceAddress: String
  practicePhone: String
  practiceEmail: String
  practiceWebsite: String
  
  # Availability & Services
  availability: AWSJSON
  consultationFee: Float
  services: [String]
  
  # Profile & Media
  bio: String
  profileImage: String
  coverImage: String
  
  # Status & Verification
  isVerified: Boolean! @default(value: "false")
  isActive: Boolean! @default(value: "true")
  verificationStatus: String @default(value: "pending") # pending, verified, rejected
  
  # Relationships
  appointments: [Appointment] @hasMany(fields: ["id"])
  expertPatients: [ExpertPatient] @hasMany(fields: ["id"])
  patientRecords: [PatientRecord] @hasMany(fields: ["id"])
  
  createdAt: AWSDateTime!
  updatedAt: AWSDateTime!
}

type Appointment @model @auth(rules: [
  { allow: owner, operations: [create, read, update, delete] },
  { allow: private, operations: [read] },
  { allow: public, provider: apiKey, operations: [read, create, update, delete] }
]) {
  id: ID!
  userId: ID!
  expertId: ID!
  date: AWSDateTime!
  status: String! # scheduled, completed, cancelled, rescheduled
  type: String! # consultation, follow-up, emergency, routine
  duration: Int # in minutes
  notes: String
  symptoms: String
  diagnosis: String
  prescription: String
  followUpDate: AWSDateTime
  
  user: User @hasOne(fields: ["userId"])
  expert: Expert @hasOne(fields: ["expertId"])
  
  createdAt: AWSDateTime!
  updatedAt: AWSDateTime!
}

# Relationship between Users and Experts (when users add experts as their specialists)
type ExpertPatient @model @auth(rules: [
  { allow: owner, operations: [create, read, update, delete] },
  { allow: public, provider: apiKey, operations: [read, create, update, delete] }
]) {
  id: ID!
  userId: ID!
  expertId: ID!
  status: String! # active, inactive, pending
  addedAt: AWSDateTime!
  notes: String
  
  user: User @hasOne(fields: ["userId"])
  expert: Expert @hasOne(fields: ["expertId"])
  
  createdAt: AWSDateTime!
  updatedAt: AWSDateTime!
}

# Patient records for external patients (not platform users)
type PatientRecord @model @auth(rules: [
 { allow: owner, operations: [create, read, update, delete] },
  { allow: groups, groups: ["expert", "admin"], operations: [create, read, update] }

]) {
  id: ID!
  expertId: ID!
  
  # Patient Information
  firstName: String!
  lastName: String!
  dateOfBirth: AWSDate
  gender: String
  phoneNumber: String
  email: String
  address: String
  emergencyContact: String
  
  # Medical Information
  medicalHistory: String
  allergies: String
  currentMedications: String
  familyHistory: String
  
  # Records
  appointments: [String] # Array of appointment IDs
  notes: String
  documents: [String] # Array of document URLs
  
  expert: Expert @hasOne(fields: ["expertId"])
  
  createdAt: AWSDateTime!
  updatedAt: AWSDateTime!
}

type AuditEvent @model @auth(rules: [
  { allow: public, provider: apiKey, operations: [create, read, update] }
]) {
  id: ID!
  timestamp: AWSDateTime!
  userId: String!
  action: String!
  resourceId: String!
  details: AWSJSON!
  transactionHash: String
  merkleRoot: String
  batchId: String
}

type AuditBatch @model @auth(rules: [
  { allow: public, provider: apiKey, operations: [create, read, update] }
]) {
  id: ID!
  timestamp: AWSDateTime!
  merkleRoot: String!
  transactionHash: String!
  events: [AuditEvent] @hasMany
}

type DietaryPlan @model @auth(rules: [
  { allow: public, provider: apiKey, operations: [create, read, update, delete] },
  { allow: owner, operations: [create, read, update, delete] }
]) {
  id: ID!
  userId: ID!
  name: String!
  category: String! # breakfast, lunch, dinner, snack
  calories: Int!
  protein: Float!
  carbs: Float!
  fat: Float!
  fiber: Float!
  isRecommended: Boolean!
  isCompleted: Boolean!
  time: String
  reason: String
  user: User @belongsTo(fields: ["userId"])
  createdAt: AWSDateTime!
  updatedAt: AWSDateTime!
}

type HealthGoal @model @auth(rules: [
  { allow: public, provider: apiKey, operations: [create, read, update, delete] },
  { allow: owner, operations: [create, read, update, delete] }
]) {
  id: ID!
  userId: ID!
  title: String!
  description: String!
  category: String! # fitness, nutrition, mental, medical, lifestyle
  target: Float!
  current: Float!
  unit: String!
  deadline: AWSDate!
  isCompleted: Boolean!
  isRecommended: Boolean!
  priority: String! # low, medium, high
  reward: Int! # HAIC tokens
  reason: String
  user: User @belongsTo(fields: ["userId"])
  createdAt: AWSDateTime!
  updatedAt: AWSDateTime!
}

type HealthCondition @model @auth(rules: [
  { allow: public, provider: apiKey, operations: [create, read, update, delete] },
  { allow: owner, operations: [create, read, update, delete] }
]) {
  id: ID!
  userId: ID!
  name: String!
  severity: String! # mild, moderate, severe
  status: String! # active, managed, resolved
  diagnosedDate: AWSDate!
  description: String!
  medications: String
  user: User @belongsTo(fields: ["userId"])
  createdAt: AWSDateTime!
  updatedAt: AWSDateTime!
}

type HAICReward @model @auth(rules: [
  { allow: public, provider: apiKey, operations: [create, read, update, delete] },
  { allow: owner, operations: [create, read, update, delete] }
]) {
  id: ID!
  userId: ID!
  amount: Int!
  reason: String!
  category: String! # goal_completion, dietary_adherence, appointment_attendance, health_checkin
  transactionHash: String
  user: User @belongsTo(fields: ["userId"])
  createdAt: AWSDateTime!
  updatedAt: AWSDateTime!
}

input CreateUserInput {
  id: ID!
  email: String!
  firstName: String!
  lastName: String!
  phoneNumber: String
  dateOfBirth: AWSDate
  gender: String
  address: String
  city: String
  state: String
  zipCode: String
  emergencyContactName: String
  emergencyContactPhone: String
  allergies: String
  medicalConditions: String
  currentMedications: String
  height: Float
  weight: Float
  bloodType: String
  role: String!
  isActive: Boolean
  lastLoginAt: AWSDateTime
  loginCount: Int
  preferences: AWSJSON
  notificationSettings: AWSJSON
  privacySettings: AWSJSON
  subscriptionTier: String
  subscriptionExpiresAt: AWSDateTime
}

input UpdateUserInput {
  id: ID!
  email: String
  firstName: String
  lastName: String
  phoneNumber: String
  dateOfBirth: AWSDate
  gender: String
  address: String
  city: String
  state: String
  zipCode: String
  emergencyContactName: String
  emergencyContactPhone: String
  allergies: String
  medicalConditions: String
  currentMedications: String
  height: Float
  weight: Float
  bloodType: String
  role: String
  isActive: Boolean
  lastLoginAt: AWSDateTime
  loginCount: Int
  preferences: AWSJSON
  notificationSettings: AWSJSON
  privacySettings: AWSJSON
  subscriptionTier: String
  subscriptionExpiresAt: AWSDateTime
}

input DeleteUserInput {
  id: ID!
}



input CreateDietaryPlanInput {
  id: ID!
  userId: ID!
  name: String!
  category: String!
  calories: Int!
  protein: Float!
  carbs: Float!
  fat: Float!
  fiber: Float!
  isRecommended: Boolean!
  isCompleted: Boolean!
  time: String
  reason: String
}

input UpdateDietaryPlanInput {
  id: ID!
  userId: ID
  name: String
  category: String
  calories: Int
  protein: Float
  carbs: Float
  fat: Float
  fiber: Float
  isRecommended: Boolean
  isCompleted: Boolean
  time: String
  reason: String
}

input DeleteDietaryPlanInput {
  id: ID!
}

input CreateHealthGoalInput {
  id: ID!
  userId: ID!
  title: String!
  description: String!
  category: String!
  target: Float!
  current: Float!
  unit: String!
  deadline: AWSDate!
  isCompleted: Boolean!
  isRecommended: Boolean!
  priority: String!
  reward: Int!
  reason: String
}

input UpdateHealthGoalInput {
  id: ID!
  userId: ID
  title: String
  description: String
  category: String
  target: Float
  current: Float
  unit: String
  deadline: AWSDate
  isCompleted: Boolean
  isRecommended: Boolean
  priority: String
  reward: Int
  reason: String
}

input DeleteHealthGoalInput {
  id: ID!
}

input CreateHealthConditionInput {
  id: ID!
  userId: ID!
  name: String!
  severity: String!
  status: String!
  diagnosedDate: AWSDate!
  description: String!
  medications: String
}

input UpdateHealthConditionInput {
  id: ID!
  userId: ID
  name: String
  severity: String
  status: String
  diagnosedDate: AWSDate
  description: String
  medications: String
}

input DeleteHealthConditionInput {
  id: ID!
}

input CreateHAICRewardInput {
  id: ID!
  userId: ID!
  amount: Int!
  reason: String!
  category: String!
  transactionHash: String
}

input UpdateHAICRewardInput {
  id: ID!
  userId: ID
  amount: Int
  reason: String
  category: String
  transactionHash: String
}

input DeleteHAICRewardInput {
  id: ID!
}

# Expert Input Types
input CreateExpertInput {
  id: ID!
  userId: ID!
  specialization: String!
  subSpecializations: [String]
  licenseNumber: String!
  yearsOfExperience: Int!
  education: [String]
  certifications: [String]
  languages: [String]
  practiceName: String
  practiceAddress: String
  practicePhone: String
  practiceEmail: String
  practiceWebsite: String
  availability: AWSJSON
  consultationFee: Float
  services: [String]
  bio: String
  profileImage: String
  coverImage: String
  isVerified: Boolean
  isActive: Boolean
  verificationStatus: String
}

input UpdateExpertInput {
  id: ID!
  userId: ID
  specialization: String
  subSpecializations: [String]
  licenseNumber: String
  yearsOfExperience: Int
  education: [String]
  certifications: [String]
  languages: [String]
  practiceName: String
  practiceAddress: String
  practicePhone: String
  practiceEmail: String
  practiceWebsite: String
  availability: AWSJSON
  consultationFee: Float
  services: [String]
  bio: String
  profileImage: String
  coverImage: String
  isVerified: Boolean
  isActive: Boolean
  verificationStatus: String
}

input DeleteExpertInput {
  id: ID!
}

# ExpertPatient Input Types
input CreateExpertPatientInput {
  id: ID!
  userId: ID!
  expertId: ID!
  status: String!
  addedAt: AWSDateTime!
  notes: String
}

input UpdateExpertPatientInput {
  id: ID!
  userId: ID
  expertId: ID
  status: String
  addedAt: AWSDateTime
  notes: String
}

input DeleteExpertPatientInput {
  id: ID!
}

# PatientRecord Input Types
input CreatePatientRecordInput {
  id: ID!
  expertId: ID!
  firstName: String!
  lastName: String!
  dateOfBirth: AWSDate
  gender: String
  phoneNumber: String
  email: String
  address: String
  emergencyContact: String
  medicalHistory: String
  allergies: String
  currentMedications: String
  familyHistory: String
  appointments: [String]
  notes: String
  documents: [String]
}

input UpdatePatientRecordInput {
  id: ID!
  expertId: ID
  firstName: String
  lastName: String
  dateOfBirth: AWSDate
  gender: String
  phoneNumber: String
  email: String
  address: String
  emergencyContact: String
  medicalHistory: String
  allergies: String
  currentMedications: String
  familyHistory: String
  appointments: [String]
  notes: String
  documents: [String]
}

input DeletePatientRecordInput {
  id: ID!
}

# Updated Appointment Input Types
input CreateAppointmentInput {
  id: ID!
  userId: ID!
  expertId: ID!
  date: AWSDateTime!
  status: String!
  type: String!
  duration: Int
  notes: String
  symptoms: String
  diagnosis: String
  prescription: String
  followUpDate: AWSDateTime
}

input UpdateAppointmentInput {
  id: ID!
  userId: ID
  expertId: ID
  date: AWSDateTime
  status: String
  type: String
  duration: Int
  notes: String
  symptoms: String
  diagnosis: String
  prescription: String
  followUpDate: AWSDateTime
}

input DeleteAppointmentInput {
  id: ID!
}
